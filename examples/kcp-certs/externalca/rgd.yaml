apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: certificates.example.platform-mesh.io
spec:

  schema:
    group: example.platform-mesh.io
    apiVersion: v1alpha1
    kind: Certificate
    spec:
      fqdn: string
    status:
      status: ${certificate.status.conditions.exists(c, c.type == "Ready" && c.status == "True") ? "Available":"Unavailable"}
      conditions: ${certificate.status.conditions}
      relatedResources:
        secret:
          gvk:
            group: ${secret.apiVersion == "v1" ? "core":secret.apiVersion.split("/")[0]}
            version: ${secret.?apiVersion}
            kind: ${secret.?kind}
          name: ${secret.metadata.name}
          # This is a mapping problem between the consumer workspace,
          # resource-broker, the provider virtual workspace and the
          # provider cluster.
          # api-syncagent writes into a namespace matching the consumer
          # workspace cluster name, resulting in kro noting the consumer
          # workspace as the namespace here - which is correct locally.
          # However when api-syncagent syncs the resources back into the
          # VW the namespace changes back to 'default' (or wherever the
          # resource originated from). For the PoC we hardcode the
          # default namespace.
          # This is one of the problems that would need a proper
          # solution.
          namespace: ${certificate.metadata.?annotations["remote-object-namespace"]}

  resources:

    - id: certificate
      template:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          annotations:
            remote-object-name: ${schema.metadata.?annotations["syncagent.kcp.io/remote-object-name"]}
            remote-object-namespace: ${schema.metadata.?annotations["syncagent.kcp.io/remote-object-namespace"]}
          name: ${schema.metadata.name}
          namespace: ${schema.metadata.namespace}
        spec:
          commonName: ${schema.spec.fqdn}
          secretName: ${schema.metadata.name}
          privateKey:
            algorithm: ECDSA
            size: 256
          issuerRef:
            name: selfsigned-cluster-issuer
            kind: ClusterIssuer
            group: cert-manager.io

    - id: secret
      externalRef:
        apiVersion: v1
        kind: Secret
        metadata:
          name: ${certificate.metadata.name}
          namespace: ${certificate.metadata.namespace}
